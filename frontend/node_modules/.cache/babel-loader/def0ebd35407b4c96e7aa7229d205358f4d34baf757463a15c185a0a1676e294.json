{"ast":null,"code":"// import axios from 'axios';\nimport axiosInstance from'../../authToken';// Action types\nconst FETCH_GROUNDS_REQUEST='FETCH_GROUNDS_REQUEST';const FETCH_GROUNDS_SUCCESS='FETCH_GROUNDS_SUCCESS';const FETCH_GROUNDS_FAILURE='FETCH_GROUNDS_FAILURE';export const FETCH_GROUNDS_REQUEST_USER='FETCH_GROUNDS_REQUEST_USER';export const FETCH_GROUNDS_SUCCESS_USER='FETCH_GROUNDS_SUCCESS_USER';export const FETCH_GROUNDS_FAILURE_USER='FETCH_GROUNDS_FAILURE_USER';export const UPDATE_GROUND_REQUEST='UPDATE_GROUND_REQUEST';export const UPDATE_GROUND_SUCCESS='UPDATE_GROUND_SUCCESS';export const UPDATE_GROUND_FAILURE='UPDATE_GROUND_FAILURE';export const createGround=groundData=>async(dispatch,getState)=>{try{const token=getState().auth.token;console.log(token,\"token\");const res=await axiosInstance.post('/auth/createGrounds',groundData);// Adjust API endpoint as needed\ndispatch({type:'CREATE_GROUND_SUCCESS',payload:res.data});return Promise.resolve(res.data);// Return a resolved promise if successful\n}catch(err){dispatch({type:'CREATE_GROUND_FAILURE',payload:err.response.data.msg});return Promise.reject(err);// Return a rejected promise if there's an error\n}};export const updateGround=entry=>async(dispatch,getState)=>{debugger;console.log(entry,\"entry\");try{const token=getState().auth.token;// Get the token from the state\nconsole.log(token,\"token\");// Use the groundData to send the appropriate update request\nconst res=await axiosInstance.put(`/auth/grounds/${entry.id}`,entry);// Adjust API endpoint as needed\n// Dispatch success action with the updated ground data\ndispatch({type:'UPDATE_GROUND_SUCCESS',payload:res.data});return Promise.resolve(res.data);// Return a resolved promise if successful\n}catch(err){// Dispatch failure action with the error message\ndispatch({type:'UPDATE_GROUND_FAILURE',payload:err.response?err.response.data.msg:'Update failed'});return Promise.reject(err);// Return a rejected promise if there's an error\n}};// Fetch Grounds Action\nexport const fetchGrounds=()=>{return async dispatch=>{dispatch({type:FETCH_GROUNDS_REQUEST});try{const response=await axiosInstance.get('/auth/myGrounds');// Adjust the URL as needed\ndispatch({type:FETCH_GROUNDS_SUCCESS,payload:response.data});return Promise.resolve(response.data);// Return a resolved promise if successful\n}catch(error){dispatch({type:FETCH_GROUNDS_FAILURE,payload:error.message});return Promise.reject(error);// Return a rejected promise if there's an error\n}};};export const fetchUserGrounds=()=>async dispatch=>{dispatch({type:FETCH_GROUNDS_REQUEST_USER});try{const response=await axiosInstance.get('/auth/grounds');// API to fetch all grounds\ndispatch({type:FETCH_GROUNDS_SUCCESS_USER,payload:response.data.grounds});return Promise.resolve(response.data);}catch(error){dispatch({type:FETCH_GROUNDS_FAILURE_USER,payload:error.message});return Promise.reject(error);// Return a rejected promise if there's an error\n}};","map":{"version":3,"names":["axiosInstance","FETCH_GROUNDS_REQUEST","FETCH_GROUNDS_SUCCESS","FETCH_GROUNDS_FAILURE","FETCH_GROUNDS_REQUEST_USER","FETCH_GROUNDS_SUCCESS_USER","FETCH_GROUNDS_FAILURE_USER","UPDATE_GROUND_REQUEST","UPDATE_GROUND_SUCCESS","UPDATE_GROUND_FAILURE","createGround","groundData","dispatch","getState","token","auth","console","log","res","post","type","payload","data","Promise","resolve","err","response","msg","reject","updateGround","entry","put","id","fetchGrounds","get","error","message","fetchUserGrounds","grounds"],"sources":["F:/CRIC/frontend/src/redux/actions/groundActions.js"],"sourcesContent":["// import axios from 'axios';\r\nimport axiosInstance from '../../authToken';\r\n// Action types\r\nconst FETCH_GROUNDS_REQUEST = 'FETCH_GROUNDS_REQUEST';\r\nconst FETCH_GROUNDS_SUCCESS = 'FETCH_GROUNDS_SUCCESS';\r\nconst FETCH_GROUNDS_FAILURE = 'FETCH_GROUNDS_FAILURE';\r\n\r\nexport const FETCH_GROUNDS_REQUEST_USER = 'FETCH_GROUNDS_REQUEST_USER';\r\nexport const FETCH_GROUNDS_SUCCESS_USER = 'FETCH_GROUNDS_SUCCESS_USER';\r\nexport const FETCH_GROUNDS_FAILURE_USER = 'FETCH_GROUNDS_FAILURE_USER';\r\n\r\nexport const UPDATE_GROUND_REQUEST = 'UPDATE_GROUND_REQUEST';\r\nexport const UPDATE_GROUND_SUCCESS = 'UPDATE_GROUND_SUCCESS';\r\nexport const UPDATE_GROUND_FAILURE = 'UPDATE_GROUND_FAILURE';\r\n\r\nexport const createGround = (groundData) => async (dispatch,getState) => {\r\n  try {\r\n    const token = getState().auth.token;\r\n    console.log(token, \"token\");\r\n    const res = await axiosInstance.post('/auth/createGrounds', groundData); // Adjust API endpoint as needed\r\n    dispatch({ type: 'CREATE_GROUND_SUCCESS', payload: res.data });\r\n    return Promise.resolve(res.data); // Return a resolved promise if successful\r\n  } catch (err) {\r\n    dispatch({ type: 'CREATE_GROUND_FAILURE', payload: err.response.data.msg });\r\n    return Promise.reject(err); // Return a rejected promise if there's an error\r\n  }\r\n};\r\nexport const updateGround = (entry) => async (dispatch, getState) => {\r\n  debugger;\r\n  console.log(entry, \"entry\");\r\n  try {\r\n    const token = getState().auth.token; // Get the token from the state\r\n    console.log(token, \"token\");\r\n    \r\n    // Use the groundData to send the appropriate update request\r\n    const res = await axiosInstance.put(`/auth/grounds/${entry.id}`, entry); // Adjust API endpoint as needed\r\n    \r\n    // Dispatch success action with the updated ground data\r\n    dispatch({ type: 'UPDATE_GROUND_SUCCESS', payload: res.data });\r\n    return Promise.resolve(res.data); // Return a resolved promise if successful\r\n  } catch (err) {\r\n    // Dispatch failure action with the error message\r\n    dispatch({ type: 'UPDATE_GROUND_FAILURE', payload: err.response ? err.response.data.msg : 'Update failed' });\r\n    return Promise.reject(err); // Return a rejected promise if there's an error\r\n  }\r\n};\r\n// Fetch Grounds Action\r\nexport const fetchGrounds = () => {\r\n  return async (dispatch) => {\r\n    dispatch({ type: FETCH_GROUNDS_REQUEST });\r\n    try {\r\n      const response = await axiosInstance.get('/auth/myGrounds'); // Adjust the URL as needed\r\n      dispatch({ type: FETCH_GROUNDS_SUCCESS, payload: response.data });\r\n      return Promise.resolve(response.data); // Return a resolved promise if successful\r\n    } catch (error) {\r\n      dispatch({ type: FETCH_GROUNDS_FAILURE, payload: error.message });\r\n      return Promise.reject(error); // Return a rejected promise if there's an error\r\n    }\r\n  };\r\n};\r\n\r\nexport const fetchUserGrounds = () => async dispatch => {\r\n  dispatch({ type: FETCH_GROUNDS_REQUEST_USER });\r\n  try {\r\n    const response = await axiosInstance.get('/auth/grounds'); // API to fetch all grounds\r\n    dispatch({ type: FETCH_GROUNDS_SUCCESS_USER, payload: response.data.grounds });\r\n    return Promise.resolve(response.data);\r\n  } catch (error) {\r\n    dispatch({ type: FETCH_GROUNDS_FAILURE_USER, payload: error.message });\r\n    return Promise.reject(error); // Return a rejected promise if there's an error\r\n  }\r\n};\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}